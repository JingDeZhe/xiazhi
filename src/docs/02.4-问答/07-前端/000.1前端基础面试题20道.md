# JS 中`==`和`===`的区别

`==` 是比较操作符，用于比较两个值是否相等，它会进行类型转换，然后再进行比较，而`===` 是严格比较符，它会进行类型转换和值比较，只有类型和值都相同，才会返回 true。

由于`==`号会进行类型转换，因此结果经常会存在误导性，在一般的场合下，应该避免使用`==`，而应该使用`===`来避免隐式的类型转换造成的偏差和误导。

# JS 中 bind、call、apply 的作用和区别是什么？

这三者的作用都是为了改变函数内部 this 的指向，使得函数可以在指定的上下文中执行。

call 和 apply 使用时都会立即执行函数，区别在于 apply 可以接受一个数组作为参数列表，而 call 则需要将参数逐个列举出来。
bind 则是返回一个新的函数，需要手动调用，新函数的 this 指向 bind 的具体对象。

# 什么是原型链

在 JS 中，对象是由函数创建的，每个函数都有一个 prototype 属性，这个属性指向一个对象，这个对象就是该函数的原型对象，而函数的实例对象也有一个 `__proto__` 属性，这个属性指向该函数的原型对象，这样就形成了一个原型链。

> 注意`__proto__`并非 JS 的标准属性，只是浏览器为了方便开发者访问原型对象而添加的属性，在 ES6 中，可以使用 Object.getPrototypeOf()方法来获取对象的原型对象。

在 JS 中，每个对象都有一个原型对象，原型对象也是一个对象，它也有自己的原型对象，以此类推，形成一个原型链。当访问一个对象的属性时，如果该对象没有该属性，会沿着原型链向上查找，直到找到该属性或者到达原型链的顶端。

原型链的作用是实现了对象之间的继承和共享，使得对象可以继承和共享其原型对象的属性和方法，从而提高了代码的复用性和可维护性，比如说所有字符串都继承了 String.prototype 的属性和方法，所有数组都继承了 Array.prototype 的属性和方法，所有函数都继承了 Function.prototype 的属性和方法。

# 什么是闭包，闭包的使用场景是什么？

闭包是指一个函数，它可以访问其外部函数的作用域中的变量，即使外部函数已经执行完毕。在 JS 中，闭包通常用于封装私有变量和函数，以实现隐藏局部变量、或者实现函数柯里化的目的。

> 函数柯里化是指将接受多个参数的函数转换为接受转换为一系列单参数的函数，它通过闭包来保存之前传入的参数，使得每次调用函数时只需要传入剩余的参数，从而实现了函数的部分求值和参数复用，提高了函数的灵活性和复用性。

# 什么是 MVC 和 MVVM？

MVC 是一种软件设计模式，它将应用程序分为三个部分：模型（Model）、视图（View）和控制器（Controller），其中模型负责处理数据，视图负责显示数据，控制器负责处理用户的输入和更新模型和视图。

而 MVVM 将应用程序分为三个部分：模型（Model）、视图（View）和视图模型（ViewModel），其中模型负责处理数据，视图负责显示数据，视图模型负责处理用户的输入和更新模型和视图。

MVC 和 MVVM 的优点是可以将应用程序的不同部分分离，使得代码更加清晰、可维护和可测试。两者的区别在于 MVC 是单向的数据流，而 MVVM 是双向数据流，即数据可以从视图模型流向模型，也可以从模型流向视图模型。

# Vue 间的组件传参有哪些方式？

1. 使用 props 传参

父组件通过 props 给子组件传参，子组件在内部使用 props 来接收参数

需要注意的是，由于 Vue 中的 props 是单向数据流，即父组件向子组件传递的数据是只读的，子组件无法直接修改父组件传递的 props 数据。如果需要修改父组件的数据，可以通过在子组件中触发事件，由父组件来修改数据。

1. 使用$emit 传参

子组件通过$emit 触发事件，父组件通过监听事件来接收参数

3. 使用自定义事件总线

使用 EventBus 来实现组件间的跨层级传参

4. 使用 provide/inject

如果组件传参层级很深，可以使用 provide/inject 来实现跨层级传参

5. 使用状态管理局，如 Vuex、Pinia

使用状态管理局来管理全局状态，实现组件间的传参

# Vue 中 v-model 的基本原理，如何实现自定义组件的 v-model

在 Vue 中，v-model 本质上是一个语法糖，它用于在表单元素或自定义组件上创建双向数据绑定，原生的 v-model 实际上是 value 属性和 input 事件的语法糖，它的实现原理如下：

```html
<input type="text" :value="value" @input="value = $event.target.value" />
```

要实现自定义组件的 v-model，需要满足以下两个条件：

1. 在自定义组件中，必须接受一个名为 value 的 prop，这个 prop 将用于接收来自父组件的数据。
2. 在自定义组件内部，当数据发生变化时，必须通过$emit('input', newValue)的方式将新的值发送给父组件，从而更新父组件中绑定的数据。

Vue2 中组件只能有一个 v-model，Vue3 中组件可以有多个 v-model, 可以通过修饰符来区分不同的 v-model。

# Vue 中的生命周期是什么，有哪些常用的生命周期？

Vue 中组件从创建到销毁的过程中，会依次触发一系列的生命周期钩子函数，这些钩子函数可以在组件的不同阶段执行特定的逻辑，从而实现组件的初始化、更新和销毁等操作，统称为生命周期。

常见的生命周期函数有：

1. created：组件实例创建完成后调用，此时组件已经完成了初始化，但还没有挂载到 DOM 中。
2. mounted：组件实例挂载到 DOM 中后调用，此时组件已经可以访问到 DOM 元素。
3. destroyed：组件实例销毁后调用，此时组件已经从 DOM 中移除。

组件的数据请求一般在 created 中进行，因为此时组件已经完成了初始化，还没有挂载到 DOM 中，因此可以在 created 中进行数据请求，但对于需要和 DOM 进行交互的操作，应该在 mounted 中进行，因为此时组件已经挂载到 DOM 中，可以访问到 DOM 元素。

# Vue 中给对象添加属性页面不发生变化的原因是什么？

Vue2 中使用 defineProperty 给对象添加属性，以确保属性的响应性。以普通的方式添加属性页面不会发生变化，因为 defineProperty 只能拦截对象的属性操作，而不能拦截对象的新增属性，因此碰到这种情况，需要使用 Vue.set 方法来添加属性，它能保证新添加的属性也是响应性的。

# Vue 的 v-for 循环中，key 的作用是什么？

Vue 在进行虚拟 DOM 的比较和更新时，会根据 key 属性来准确地识别每个节点。当数据发生变化时，Vue 会通过比较新旧虚拟 DOM 树中节点的 key 值，来确定哪些节点是新增的、哪些是被删除的、哪些是需要更新的。如果没有 key，Vue 可能会错误地复用节点，导致数据与视图可能会不一致。

# Vue 中插槽的作用是什么？

Vue 中插槽可以让用户在复用组件的时候，对组件的一部分内容进行替换，从而实现组件复用的灵活性，比如说 Select 组件中的插槽可以让用户在使用组件的时候，对 Select 组件中的下拉框选项进行替换。

插槽分为默认插槽和具名插槽，默认插槽只能有一个，具名插槽可以有多个，具名插槽可以通过 name 属性来指定。

在使用插槽的时候，可以通过 slot-scope 或 v-slot 来指定插槽的作用域，使插槽可以方便地访问子组件内部暴露的方法和数据。

# Vue 中的 nextTick 有什么作用

Vue 在更新 DOM 时是异步执行的，当数据发生变化时，Vue 会开启一个异步更新队列，将所有需要更新 DOM 的操作放入队列中，等到下一个事件循环 时，才会一次性地将队列中的所有 DOM 更新操作执行完毕。因此，对数据的操作并不会立刻反应在 DOM 中，如果立刻获取 DOM，便会获取到旧的 DOM。

nextTick 提供了一种机制，让我们可以在 DOM 更新完成后执行一些操作。例如，当我们在 Vue 实例的 mounted 钩子函数中修改了数据，并且希望在 DOM 更新后立即获取到更新后的 DOM 元素的属性或执行一些基于更新后 DOM 状态的操作时，就可以使用 nextTick，如 el-table 中修改数据后对显示内容重新计算布局。

# Vue3 和 Vue2 有什么区别？

1. 响应式系统

Vue2 使用 Object.defineProperty () 进行数据劫持来实现响应式，而 Vue3 则采用 Proxy 代理对象，Proxy 可以直接监听对象和数组的变化，无需像 Vue2 那样进行特殊处理，并且在性能上有显著提升，尤其是在处理大型复杂数据结构时。

2. 组合式 API

Vue3 新增了组合式 API，如 setup 函数、ref、reactive 等，它允许开发者更灵活地组织和复用代码逻辑，将相关的逻辑代码放在一起，提高了代码的可读性和可维护性，尤其适用于大型复杂组件的开发。相比之下，Vue2 主要使用 Options API，将数据、方法、生命周期等都放在一个对象中。

3. 其它细节
   1. Vue3 对 typescript 的支持更好
   2. Vue3 支持组件多个根节点
   3. Vue3 对模板语法进行了一些小的改进，如 v-if 和 v-for 的优先级调整，在同一元素上使用时，v-if 的优先级更高，这与 Vue2 有所不同
   4. Vue3 新增了 Teleport 组件，用于将模板的一部分渲染到 DOM 中的其他位置

# 浏览器中本地储存的方式有哪些？

1. cookie

Cookie 是最传统的浏览器本地存储方式，以键值对的形式存储数据。它的大小通常限制在 4KB 左右，并且每次向服务器发送请求时，会自动携带当前域名下的所有 Cookie。Cookie 的有效期可以通过设置过期时间来控制，过期后会自动被浏览器删除。

Cookie 一般用在和服务器进行交互的场景，比如登录状态的保存、用户偏好设置的保存等。

2. localStorage

LocalStorage 是 HTML5 新增的本地存储方式，存储容量一般在 5MB 左右，比 Cookie 大很多。它的数据不会随着 HTTP 请求发送到服务器，只会在本地浏览器中持久保存，除非用户手动清除或通过 JavaScript 代码删除。

LocalStorage 适合存储一些长期需要保存的数据，如用户的个性化设置、应用的配置信息等，这些数据在用户下次访问时仍然有效，无需再次从服务器获取。

3. sessionStorage

SessionStorage 和 LocalStorage 类似，都是 HTML5 新增的本地存储方式，它们的区别在于 SessionStorage 的数据只在当前会话中有效，一旦会话结束，数据就会被清除。

4. indexedDB

IndexedDB 是一个基于 JavaScript 的面向对象数据库，用于在浏览器中存储和检索大量结构化数据。它的存储容量比 localStorage 和 sessionStorage 大得多，理论上没有明确的上限，具体取决于浏览器和设备的可用存储空间，和 LocalStorage 不同，indexedDB 是异步的。

IndexedDB 适合存储大量的结构化数据，如应用的离线数据缓存、客户端的数据库应用等，特别是对于需要进行复杂查询和数据管理的场景，IndexedDB 是一个更强大的选择。

# 简述 ES6 中的类

ES6 中的类是一种语法糖，它使得 JavaScript 中的面向对象编程更加接近传统的面向对象编程语言的语法风格，而不用来使用构造函数和原型链等传统的面向对象编程方式。

在 ES6 中，使用 class 关键字来定义一个类，类中可以定义构造函数、实例方法、静态方法、getter 和 setter 等，也可以实现继承和多态等面向对象编程的特性。

可以通过 new 关键字来创建类的实例，实例可以访问类中的属性和方法。

## new 操作符的步骤

1. 创建一个空对象
2. 空对象的内部属性 **proto** 赋值为构造函数的 prototype 属性
3. 将构造函数的 this 指向空对象
4. 执行构造函数内部代码
5. 返回该新对象

# async、await 的作用和使用场景

async 函数是一种异步函数，它可以让函数内部的异步操作变得更加简单和直观。async 函数返回一个 Promise 对象，当函数执行完毕后，Promise 对象会被 resolve，函数返回的值就是 Promise 对象的值。

async 内部可以使用 await 关键字来等待一个异步操作的结果，而不用频繁地使用回调函数，简化了多个异步操作的代码结构，提高了代码的可读性和可维护性。

# 什么是节流和防抖？

节流和防抖都是为了优化性能的手段，它们可以限制函数的执行频率，避免函数被频繁地调用，从而提高页面的响应速度和用户体验。

节流是指在一定的时间间隔内，只允许函数执行一次，即使函数被频繁地调用，也只会在规定的时间间隔内执行一次。比如说监听窗口的 resize 事件、滚动条事件等，在一定的时间间隔内，只执行一次，避免函数被频繁地调用，从而提高页面的响应速度和用户体验。

防抖是指在一定的时间间隔内，只有函数最后一次调用才会执行，前面的调用都会被忽略。比如说搜索框的输入远程搜索，在用户输入完成后，才会执行搜索请求，避免了频繁的请求，提高了用户体验。

# 箭头函数和普通函数的区别

1. 箭头函数没有自己的 this，它的 this 是继承自外层作用域的 this，普通函数的 this 是调用时的对象。
2. 箭头函数不能使用 call、apply、bind 方法改变 this 的指向，普通函数可以。
3. 箭头函数不能作为构造函数，普通函数可以。
4. 箭头函数没有原型对象，普通函数有。
5. 箭头函数不能使用 new 关键字创建对象，普通函数可以。
6. 箭头函数没有 arguments 对象，普通函数有。
7. 普通函数可以提升，箭头函数不能提升。

箭头函数由于没有自己的 this，所以不能作为构造函数使用，也不能使用 new 关键字创建对象。因此，箭头函数通常用于回调函数、事件处理函数等场景，而普通函数则更加灵活，可以用于构造函数、对象方法等场景。

在 Vue 中，使用箭头函数可以避免由于 this 指向问题导致的错误，同时也可以提高代码的可读性和可维护性，但对于 computed 和 methods 中的方法，由于需要使用 this 指向当前实例，因此需要使用普通函数。

# 什么是跨域，前端处理跨域的方式有哪些？

跨域是指在浏览器中，由于同源策略的限制，无法直接访问其他域名下的资源，例如无法通过 AJAX 请求获取其他域名下的数据。

跨域的常见处理方式有：

1. CORS

通过在服务器端设置响应头来允许特定的源访问其资源。浏览器发起跨域请求时，会先发送预检请求（OPTIONS）询问服务器是否允许跨域访问，服务器根据自身配置返回相应的响应头，若允许则浏览器继续发送实际请求并获取数据。

2. JSONP

利用`<script>`标签不受同源策略限制的特性，通过动态创建`<script>`标签，将其 src 属性指向不同源的 URL，并在 URL 中携带一个回调函数名作为参数。服务器收到请求后，将数据包装在该回调函数中返回一段 JavaScript 脚本，浏览器加载此脚本时会自动执行回调函数，从而实现数据传递。

3. 代理

在同源的服务器端设置代理服务器，将前端的跨域请求转发到目标服务器，然后把目标服务器的响应返回给前端。这样在浏览器看来，请求是发送到同源的服务器，从而绕过了跨域限制。

# 如何处理前端中的精确计算问题？

由于 JavaScript 的数字类型是基于 IEEE 754 标准的双精度浮点数，在进行一些精确计算时可能会出现精度丢失的问题，例如 `0.1 + 0.2 !== 0.3`，因此，对于这种涉及到浮点数的精确计算，需要采取特别的方式：

1. 使用 BigInt

BigInt 是 JavaScript 中的一种新的原始数据类型，用于表示任意精度的整数。在进行整数计算时，可以使用 BigInt 类型来避免浮点数精度丢失的问题。对于小数计算，可以先将小数转换为整数进行计算，然后再将结果转换回小数。

2. 使用第三方库，如 decimal.js、bignumber.js

有一些专门为解决 JavaScript 精确计算问题而开发的库，如 decimal.js、bignumber.js 等。这些库提供了更丰富的功能和更精确的计算方法，可以处理各种复杂的数学运算，并确保计算结果的精度。

总结来说，前端不应该直接处理数据的精确计算问题，最好是由后端来处理，前端只负责数据的展示和交互。
