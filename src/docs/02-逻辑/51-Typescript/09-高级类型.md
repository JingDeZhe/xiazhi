# 高级类型

## 简述

这里说的高级类型可以宽泛认为是包含了以下特性的类型：

1. extends 作为泛型约束中的条件判断
2. 使用 infer 用以推断类型
3. 用到了类型的递归
4. 用到了分配条件类型等高级概念
5. ……

## 子类型和超类型

在 TypeScript 中，子类型和超类型是类型系统中的重要概念，它们有助于我们理解和组织类型之间的关系。下面将分别解释子类型和超类型的概念，并提供一些相关的 TypeScript 示例。

### 子类型（Subtype）

1. **定义**：如果类型 A 的值可以被安全地用作类型 B 的值，那么我们说类型 A 是类型 B 的子类型。换句话说，子类型是其超类型的一个特例或更具体的实现。
2. **里氏替换原则**：在程序中，任何使用了超类型（基类或接口）的地方，都可以用其子类型进行替换，而程序的行为保持不变。这是面向对象设计的基本原则之一，也是判断子类型关系的重要依据。
3. **示例**：在 TypeScript 中，我们可以通过继承或实现接口来创建子类型。例如，如果有一个`Animal`类和一个`Dog`类继承自`Animal`，那么`Dog`就是`Animal`的子类型。

```typescript
class Animal {
  makeSound(): void {
    // ...
  }
}

class Dog extends Animal {
  bark(): void {
    // ...
  }
}

let animal: Animal
let dog: Dog = new Dog()

// Dog 是 Animal 的子类型，所以可以将 dog 赋值给 animal
animal = dog
```

### 超类型（Supertype）

1. **定义**：超类型是子类型的更一般化或更抽象的类型。在 TypeScript 中，超类型通常是一个基类（class）或接口（interface），它定义了一组属性和方法的契约，子类型必须实现这些属性和方法。
2. **约束和扩展性**：超类型提供了对子类型的约束，确保子类型具有某种共同的行为或结构。同时，超类型也允许子类型在其基础上进行扩展，添加更多的特定行为或属性。
3. **示例**：继续上面的例子，`Animal`就是`Dog`的超类型。所有继承自`Animal`的类（如`Dog`）都必须实现`Animal`中定义的方法或属性。

在 TypeScript 中，子类型和超类型的关系对于实现多态性、代码复用和模块化设计至关重要。通过合理地利用这些关系，我们可以编写出更加灵活、可扩展和可维护的代码。

请注意，虽然这里主要讨论了类和接口之间的子类型和超类型关系，但 TypeScript 中的子类型和超类型概念同样适用于其他类型，如函数类型、对象类型等。在这些情况下，子类型必须满足超类型的所有要求，并可能添加额外的特定于子类型的成员。

## 子类型和子类

在 TypeScript 中，子类型和子类是两个相关但不同的概念。下面我将分别解释这两个概念，并进行归纳。

### 子类型（Subtype）

1. **定义**：子类型是类型系统中的一个概念，指的是如果一个类型 S 的结构包含了另一个类型 T 的所有成员（属性、方法等），则称 S 为 T 的子类型。

2. **特点**：

   - 子类型关系是基于结构的，不依赖于显式的继承或实现声明。
   - 如果类型 S 是类型 T 的子类型，那么在任何期望类型 T 的地方，都可以安全地使用类型 S 的值。

3. **示例**：在 TypeScript 中，如果一个接口 A 包含接口 B 的所有成员，那么接口 A 是接口 B 的子类型，即使它们之间没有显式的继承关系。

### 子类（Subclass）

1. **定义**：子类是面向对象编程中的一个概念，指的是通过继承某个父类（或称为超类、基类）而得到的新类。子类继承了父类的属性和方法，并可以添加新的属性和方法或重写父类的方法。

2. **特点**：

   - 子类与父类之间的关系是显式的，通过`extends`关键字来声明。
   - 子类可以继承父类的所有公有和保护成员（属性和方法）。
   - 子类可以添加新的成员或重写父类的成员。

3. **示例**：在 TypeScript 中，如果一个类 B 通过`extends`关键字继承了类 A，那么类 B 就是类 A 的子类。类 B 将继承类 A 的所有公有和保护成员，并可以添加自己的成员或重写类 A 的成员。

### 归纳与总结

- **子类型与子类的关系**：在 TypeScript 中，子类通常是其父类的子类型（但不是所有子类型都是子类）。这是因为子类继承了父类的所有公有和保护成员，从而满足了子类型的结构要求。然而，并非所有子类型都是通过继承得到的；它们也可以通过实现接口或具有相似的结构来形成子类型关系。
- **使用场景**：子类型主要用于类型检查和兼容性判断，在编译时确保类型安全；而子类则更多用于面向对象编程中的代码复用和扩展。

请注意，虽然子类通常是父类的子类型，但在某些情况下（如私有成员的存在或方法签名的差异），子类可能不完全满足父类的类型约束，这时它们之间的子类型关系可能会受到影响。因此，在编写 TypeScript 代码时，需要仔细考虑类之间的继承关系和类型兼容性。

## 协变和逆变

在 TypeScript 中，协变（Covariance）和逆变（Contravariance）是描述类型参数如何在函数或复杂类型中变化的术语。这两个概念主要出现在泛型、函数参数和返回类型的上下文中。

### 协变（Covariance）

协变指的是当一个类型变化时，另一个类型以相同的方向变化。在 TypeScript 中，这通常与函数的返回类型相关。如果一个函数类型`A`是另一个函数类型`B`的子类型，并且`A`的返回类型是`B`的返回类型的子类型，那么我们就说返回类型是协变的。

例如，假设我们有两个函数类型：

```typescript
type FunctionA = () => Dog
type FunctionB = () => Animal
```

在这里，`FunctionA`是`FunctionB`的子类型，因为`Dog`是`Animal`的子类型。返回类型从`Dog`到`Animal`的变化与从`FunctionA`到`FunctionB`的子类型关系是协变的。

### 逆变（Contravariance）

逆变指的是当一个类型变化时，另一个类型以相反的方向变化。在 TypeScript 中，这主要与函数参数类型相关。如果一个函数类型`A`是另一个函数类型`B`的子类型，并且`A`的参数类型是`B`的参数类型的超类型，那么我们就说参数类型是逆变的。

例如，考虑以下两个函数类型：

```typescript
type FunctionC = (animal: Animal) => void
type FunctionD = (dog: Dog) => void
```

在这个例子中，`FunctionD`是`FunctionC`的子类型，尽管`Dog`是`Animal`的子类型。这是因为你可以安全地将一个`Dog`对象传递给期望`Animal`参数的函数，但反过来则不一定安全。因此，参数类型从`Animal`到`Dog`的变化与从`FunctionC`到`FunctionD`的子类型关系是逆变的。

在 TypeScript 的实际使用中，理解协变和逆变有助于更好地掌握类型系统，特别是当处理复杂的泛型类型或函数类型时。它们解释了为什么某些类型赋值是合法的，而其他类型赋值则会导致编译错误。

总的来说，协变和逆变是类型理论中描述类型间关系变化的重要概念，在 TypeScript 的类型系统中起着关键作用。

## 分配条件类型

Distributive Conditional Types（分配条件类型）是 TypeScript 中的一个高级类型特性。以下是对其的详细解释和归纳：

1. 定义

分配条件类型是条件类型的一种特殊行为，当条件类型中的待检查类型是一个联合类型时，条件类型会被应用到联合类型的每一个成员上，这就是所谓的“分配性”。

2. 工作原理

- 当我们将一个联合类型`A | B`作为条件类型的输入时，例如`(A | B) extends U ? X : Y`，TypeScript 会分别对`A`和`B`应用条件类型，而不是将整个联合类型`A | B`视为一个整体。
- 这意味着，条件类型会针对联合类型的每个成员分别进行条件判断，并产生相应的结果类型。如果条件对某个成员成立，则应用`X`类型；如果不成立，则应用`Y`类型。

3. 示例

假设我们有以下类型定义：

```typescript
type ToArray<Type> = Type extends any ? Type[] : never
```

如果我们传入一个联合类型`string | number`给`ToArray`：

```typescript
type StrArrOrNumArr = ToArray<string | number>
```

由于分配条件类型的特性，`StrArrOrNumArr`的类型将会是`string[] | number[]`，而不是`(string | number)[]`。这是因为条件类型被分别应用到了`string`和`number`上。

4. 避免分配性

在某些情况下，我们可能想要避免这种分配性行为。为此，可以使用方括号将`extends`关键字的每一侧括起来，从而将整个联合类型作为一个整体进行处理。例如：

```typescript
type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never
type StrOrNumArr = ToArrayNonDist<string | number> // (string | number)[]
```

在这个例子中，`StrOrNumArr`的类型是`(string | number)[]`，因为分配性被避免了。

## infer

在 TypeScript 中，`infer`是一个关键字，它在条件类型（conditional types）的上下文中用于**推断（infer）类型参数**。通过使用`infer`，我们可以在类型系统中实现更加灵活和可复用的类型定义。以下是对`infer`关键字的详细解释和归纳：

1. 基本用途

   - `infer`通常用于条件类型中，条件类型是 TypeScript 中的高级类型操作符之一。
   - 通过条件类型，我们可以根据某个类型的特性，在类型系统中进行条件分支和类型的变换。

2. 在条件类型中的使用

   - 在条件语句`T extends (arg: infer R) => any ? R : T`中，`infer R`表示待推断的函数参数类型。
   - 如果`T`能赋值给`(arg: infer R) => any`，则结果是函数参数`R`的类型，否则返回为`T`。

3. 推断类型的例子

   - 可以使用`infer`来推断函数参数的类型、提取函数类型的返回值类型等。
   - 例如，`ReturnType<T>`是一个内置类型，它使用`infer`来推断并提取函数类型的返回值类型：`type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;`

4. 协变与抗变位置上的推断

   - 在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型。
   - 在抗变位置上，同一个类型变量的多个候选类型会被推断为交叉类型。

协变和逆变上文已经说过，在当前的 TS 中，仅函数参数是逆变的，因此逆变推断类型的典型例子如下：

```ts
type getIntersection<T> = T extends (a: infer P, b: infer P) => void ? P : never
type Intersection = getIntersection<(a: string, b: number) => void>
// Intersection为string & number，为交叉类型
```

## 参考

[TypeScript：一文搞懂 infer](https://juejin.cn/post/6998347146709696519)
